# 3week

# 2075. N번째 큰 수

# 1439. 뒤집기

### 문제

다솜이는 0과 1로만 이루어진 문자열 S를 가지고 있다. 다솜이는 이 문자열 S에 있는 모든 숫자를 전부 같게 만들려고 한다. 다솜이가 할 수 있는 행동은 S에서 연속된 하나 이상의 숫자를 잡고 모두 뒤집는 것이다. 뒤집는 것은 1을 0으로, 0을 1로 바꾸는 것을 의미한다.

예를 들어 S=0001100 일 때,

1. 전체를 뒤집으면 1110011이 된다.
2. 4번째 문자부터 5번째 문자까지 뒤집으면 1111111이 되어서 2번 만에 모두 같은 숫자로 만들 수 있다.

하지만, 처음부터 4번째 문자부터 5번째 문자까지 문자를 뒤집으면 한 번에 0000000이 되어서 1번 만에 모두 같은 숫자로 만들 수 있다.

문자열 S가 주어졌을 때, 다솜이가 해야하는 행동의 최소 횟수를 출력하시오.

### 풀이

 처음 문제를 봤을 때에 `0000`, `11` 과 같이 같은 수가 연속적으로 나타나는 부분을 한 덩어리로 본 후 작은 덩어리의 수를 세면 되지 않을까 생각했다.

**첫번째 정답 코드**

```c
arr = list(map(int, input().strip()))
if len(set(arr)) == 1:
    print(0)
else:
    t = []
    t.append(arr[0])
    for i in range(1, len(arr)):
        if arr[i] != arr[i-1]:
            t.append(arr[i])

    min = t.count(min(set(t), key=t.count))
    print(min)
```

 문자열을 배열형태로 받은 후 for문 안에서 arr[i]이 arr[i-1]과 다를 때에만 또 다시 append로 배열을 만든다. `0`또는 `1`을 받아 덩어리를 하나의 문자로 합친 후, `0`과 `1` 중 적게 나타난 수의 갯수를 세는 코드이다.

원래는

```c
arr = list(map(int, input().strip())):
t = []
t.append(arr[0])
for i in range(1, len(arr)):
    if arr[i] != arr[i-1]:
         t.append(arr[i])

min = t.count(min(set(t), key=t.count))
print(min)
```

이렇게 코드를 짜서 나름 짧지 않나? (아니면 말고..) 싶었는데 이렇게 코드를 만들게 되면 `11111`과 같이 하나의 수로 이루어져 있는 문자열에서는 `0`이 아닌 `1`을 출력하게 된다. 그래서 if문으로 예외처리를 해주었지만 … 너무 길다. 

그래서 고민하다가 0덩이와 1덩이(0으로 이루어진 덩어리, 1로 이루어진 덩어리를 지칭한다)의 수가 1씩 차이난다는 것을 깨닫고 새로 코드를 만들어보았다.

**두번째 정답 코드**

```c
arr = input()
c = 1
for i in range(len(arr)-1):
    if arr[i] != arr[i+1]:
        c += 1 
print(c//2)
```

카운트를 하는 변수 `c`를 선언한 후 `arr[i]`와 `arr[i+1]`이 다르면 `c += 1`을 한다.

그 후 `c`를 2로 나누면(반내림) 정답이 나온다.